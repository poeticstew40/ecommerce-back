package back.ecommerce;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class EcommerceApplication {

	public static void main(String[] args) {
		SpringApplication.run(EcommerceApplication.class, args);
		System.out.println("E-commerce application started successfully.");
	}


}
package back.ecommerce.config;

import back.ecommerce.repositories.UsuariosRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@RequiredArgsConstructor
public class ApplicationConfig {

    private final UsuariosRepository usuariosRepository;

    @Bean
    public UserDetailsService userDetailsService() {
        return username -> usuariosRepository.findByEmail(username)
                .orElseThrow(() -> new UsernameNotFoundException("Usuario no encontrado"));
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService());
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
package back.ecommerce.config;

import javax.sql.DataSource;

import org.springframework.jdbc.datasource.DriverManagerDataSource;


//@Configuration
public class DatasourceConfig {

    //@Bean
    public DataSource dataource() {
        final var datasource = new DriverManagerDataSource();
        datasource.setDriverClassName("org.h2.Driver");
        datasource.setUrl("jdbc:h2:mem:testdb");
        datasource.setUsername("sa");
        datasource.setPassword("password");

        return datasource;

    }
}
package back.ecommerce.config;

import java.io.IOException;

import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import back.ecommerce.services.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtService jwtService;
    private final UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization");
        final String jwt;
        final String userEmail;

        // üïµÔ∏è LOG 1: Ver si llega el header
        System.out.println(">>> FILTRO JWT: Procesando request a: " + request.getRequestURI());
        if (authHeader != null) {
            System.out.println(">>> FILTRO JWT: Header Authorization encontrado: " + authHeader.substring(0, Math.min(authHeader.length(), 15)) + "...");
        } else {
            System.out.println(">>> FILTRO JWT: NO hay header Authorization. Pasando como an√≥nimo.");
        }

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        jwt = authHeader.substring(7);
        try {
            userEmail = jwtService.extractUsername(jwt);
            System.out.println(">>> FILTRO JWT: Usuario extra√≠do del token: " + userEmail);
        } catch (Exception e) {
            System.out.println(">>> FILTRO JWT: Error al extraer usuario del token: " + e.getMessage());
            filterChain.doFilter(request, response);
            return;
        }

        if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);
            
            if (jwtService.isTokenValid(jwt, userDetails)) {
                System.out.println(">>> FILTRO JWT: Token V√ÅLIDO. Autenticando usuario.");
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities()
                );
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            } else {
                System.out.println(">>> FILTRO JWT: Token INV√ÅLIDO para el usuario " + userEmail);
            }
        }
        
        filterChain.doFilter(request, response);
    }
}
package back.ecommerce.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import lombok.RequiredArgsConstructor;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfiguration {

    private final JwtAuthenticationFilter jwtAuthFilter;
    private final AuthenticationProvider authenticationProvider;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // 1. Desactivar CSRF (No es necesario para APIs REST Stateless)
            .csrf(AbstractHttpConfigurer::disable)
            
            // 2. Configurar Permisos de Rutas
            .authorizeHttpRequests(auth -> auth
                // 1. Rutas 100% P√∫blicas (Login, Registro, Docs, Webhooks)
                .requestMatchers("/auth/**").permitAll()
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                .requestMatchers("/api/pagos/**").permitAll()
                .requestMatchers("/api/pagos/webhook").permitAll()

                // 2. La "Vidriera": CUALQUIERA puede VER tiendas y productos (GET)
                .requestMatchers(HttpMethod.GET, "/tiendas/**").permitAll()

                // 3. El "Mostrador": SOLO usuarios autenticados pueden CREAR tiendas (POST)
                // Esta l√≠nea es impl√≠cita por el anyRequest().authenticated(), 
                // pero el problema es que si tu token no es v√°lido o el filtro falla, te rebota.
                
                // 4. Todo lo dem√°s requiere autenticaci√≥n
                .anyRequest().authenticated()
            )

            // 3. Configurar Sesi√≥n (Stateless = Sin estado, cada petici√≥n es nueva)
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )

            // 4. Agregar nuestro AuthenticationProvider (BCrypt + UserDetails)
            .authenticationProvider(authenticationProvider)

            // 5. Agregar el Filtro JWT antes del filtro de usuario/password est√°ndar
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
package back.ecommerce.controllers;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam; // üëà FALTABA ESTE
import org.springframework.web.bind.annotation.RestController;

import back.ecommerce.dtos.AuthRequest;
import back.ecommerce.dtos.AuthResponse;
import back.ecommerce.dtos.RegisterRequest;
import back.ecommerce.services.AuthService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/auth")
@CrossOrigin(origins = "*")
@RequiredArgsConstructor
public class AuthController {

    private final AuthService authService;

    @PostMapping("/register")
    public ResponseEntity<AuthResponse> register(@Valid @RequestBody RegisterRequest request) {
        return ResponseEntity.ok(authService.register(request));
    }

    @PostMapping("/login")
    public ResponseEntity<AuthResponse> login(@RequestBody AuthRequest request) {
        return ResponseEntity.ok(authService.login(request));
    }

    @GetMapping("/verify")
    public ResponseEntity<String> verifyAccount(@RequestParam("code") String code) {
        return ResponseEntity.ok(authService.verifyUser(code));
    }
}
package back.ecommerce.controllers;

import java.net.URI;
import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import back.ecommerce.dtos.CategoriasRequest;
import back.ecommerce.dtos.CategoriasResponse;
import back.ecommerce.services.CategoriasService;
import jakarta.validation.Valid;
import lombok.AllArgsConstructor;

@RestController
@RequestMapping("/tiendas/{nombreTienda}/categorias") // üëà Ruta base din√°mica
@CrossOrigin(origins = "*")
@AllArgsConstructor
public class CategoriasController {

    private final CategoriasService categoriasService;

    @GetMapping
    public ResponseEntity<List<CategoriasResponse>> getAllByTienda(@PathVariable String nombreTienda) {
        return ResponseEntity.ok(this.categoriasService.readAllByTienda(nombreTienda));
    }

    @PostMapping
    public ResponseEntity<CategoriasResponse> postCategorias(
            @PathVariable String nombreTienda,
            @Valid @RequestBody CategoriasRequest request) {

        final var categoria = this.categoriasService.create(nombreTienda, request);

        URI location = ServletUriComponentsBuilder
                .fromCurrentContextPath()
                .path("/tienda/{nombreTienda}/categorias/{id}")
                .buildAndExpand(nombreTienda, categoria.getId())
                .toUri();

        return ResponseEntity.created(location).body(categoria);
    }

    @GetMapping("/{id}")
    public ResponseEntity<CategoriasResponse> getCategoriasById(
            @PathVariable String nombreTienda,
            @PathVariable Long id) {
        return ResponseEntity.ok(this.categoriasService.readById(id));
    }

    @PatchMapping("/{id}")
    public ResponseEntity<CategoriasResponse> updateCategoria(
            @PathVariable String nombreTienda,
            @PathVariable Long id,
            @RequestBody CategoriasRequest request) {
        return ResponseEntity.ok(this.categoriasService.update(id, request));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteCategoria(
            @PathVariable String nombreTienda,
            @PathVariable Long id) {
        this.categoriasService.delete(id);
        return ResponseEntity.noContent().build();
    }
}
package back.ecommerce.controllers;

import java.util.HashMap;
import java.util.Map;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import io.swagger.v3.oas.annotations.Hidden;

@ControllerAdvice
@Hidden
public class ErrorHandlerController {

    @ExceptionHandler(IllegalArgumentException.class)
    private ResponseEntity<Map<String, Object>>
        IllegalArgumentHandler(IllegalArgumentException ex) {
       final var response = new HashMap<String, Object>();
       
        response.put("code", HttpStatus.BAD_REQUEST.value());
        response.put("status", HttpStatus.BAD_REQUEST.getReasonPhrase());
        response.put("message", ex.getMessage());

        return ResponseEntity.badRequest().body(response);
    }

    // ‚úÖ NUEVO: Handler para validaciones (@Valid)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, Object>> handleValidationErrors(MethodArgumentNotValidException ex) {
        Map<String, Object> response = new HashMap<>();
        response.put("code", HttpStatus.BAD_REQUEST.value());
        response.put("status", "Error de Validaci√≥n");
        
        // Extrae cada campo que fall√≥ y su mensaje
        Map<String, String> errores = new HashMap<>();
        for (FieldError error : ex.getBindingResult().getFieldErrors()) {
            errores.put(error.getField(), error.getDefaultMessage());
        }
        response.put("errors", errores);

        return ResponseEntity.badRequest().body(response);
    }
}
    
package back.ecommerce.controllers;

import java.util.Map;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import back.ecommerce.entities.PedidosEntity;
import back.ecommerce.repositories.PedidosRepository;
import back.ecommerce.services.MercadoPagoService;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/pagos")
@CrossOrigin(origins = "*")
@RequiredArgsConstructor
public class MercadoPagoController {

    private final MercadoPagoService mercadoPagoService;
    private final PedidosRepository pedidosRepository;

    @PostMapping("/crear/{pedidoId}")
    public ResponseEntity<?> crearLinkDePago(@PathVariable Long pedidoId) {
        
        PedidosEntity pedido = pedidosRepository.findById(pedidoId)
                .orElseThrow(() -> new IllegalArgumentException("Pedido no encontrado"));

        if ("PAGADO".equalsIgnoreCase(pedido.getEstado()) || "APROBADO".equalsIgnoreCase(pedido.getEstado())) {
            return ResponseEntity.badRequest().body("Este pedido ya fue pagado.");
        }

        // Delegamos al servicio que ahora lee las credenciales de la configuraci√≥n
        String urlPago = mercadoPagoService.crearPreferencia(pedido);
        
        return ResponseEntity.ok(Map.of("url", urlPago));
    }
    
    @PostMapping("/webhook")
    public ResponseEntity<Void> recibirNotificacion(
            @RequestParam(value = "topic", required = false) String topic,
            @RequestParam(value = "id", required = false) Long id) {

        if ("payment".equals(topic) && id != null) {
            System.out.println("üîî Notificaci√≥n de Pago recibida. ID: " + id);
            mercadoPagoService.procesarNotificacion(id);
        }
        
        return ResponseEntity.ok().build();
    }
}
package back.ecommerce.controllers;

import java.net.URI;
import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import back.ecommerce.dtos.PedidosRequest;
import back.ecommerce.dtos.PedidosResponse;
import back.ecommerce.services.PedidosService;
import lombok.AllArgsConstructor;

@RestController
@RequestMapping("/tiendas/{nombreTienda}/pedidos") // üëà Ruta base din√°mica
@CrossOrigin(origins = "*")
@AllArgsConstructor
public class PedidosController {

    private final PedidosService pedidosService;

    // 1. Crear Pedido en la tienda
    @PostMapping
    public ResponseEntity<PedidosResponse> postPedidos(
            @PathVariable String nombreTienda,
            @RequestBody PedidosRequest request) {

        final var pedido = this.pedidosService.create(nombreTienda, request);
        
        URI location = ServletUriComponentsBuilder
                .fromCurrentContextPath()
                .path("/tienda/{nombreTienda}/pedidos/{id}")
                .buildAndExpand(nombreTienda, pedido.getId())
                .toUri();
                
        return ResponseEntity.created(location).body(pedido);
    }

    // 2. Ver todos los pedidos de la tienda (Para el admin/vendedor)
    @GetMapping
    public ResponseEntity<List<PedidosResponse>> getAllByTienda(@PathVariable String nombreTienda) {
        return ResponseEntity.ok(this.pedidosService.readAllByTienda(nombreTienda));
    }

    // 3. Ver pedidos de un usuario espec√≠fico en esta tienda
    @GetMapping("/usuario/{dni}")
    public ResponseEntity<List<PedidosResponse>> getPedidosByUsuarioDni(
            @PathVariable String nombreTienda,
            @PathVariable Long dni) {
        return ResponseEntity.ok(this.pedidosService.findByUsuarioDni(nombreTienda, dni));
    }

    // --- M√©todos por ID ---

    @GetMapping("/{id}")
    public ResponseEntity<PedidosResponse> getPedidosById(
            @PathVariable String nombreTienda,
            @PathVariable Long id) {
        return ResponseEntity.ok(this.pedidosService.readById(id));
    }

    @PatchMapping("/{id}")
    public ResponseEntity<PedidosResponse> updatePedidos(
            @PathVariable String nombreTienda,
            @PathVariable Long id, 
            @RequestBody PedidosRequest request) {
        return ResponseEntity.ok(this.pedidosService.update(id, request));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletePedidos(
            @PathVariable String nombreTienda,
            @PathVariable Long id) {
        this.pedidosService.delete(id);
        return ResponseEntity.noContent().build();
    }
}
package back.ecommerce.controllers;

import java.net.URI;
import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import back.ecommerce.dtos.ProductosRequest;
import back.ecommerce.dtos.ProductosResponse;
import back.ecommerce.services.ProductosService;
import jakarta.validation.Valid;
import lombok.AllArgsConstructor;

@RestController
@RequestMapping("/tiendas/{nombreTienda}/productos") // üëà ¬°Ruta base din√°mica!
@CrossOrigin(origins = "*")
@AllArgsConstructor
public class ProductosController {

    private final ProductosService productosService;

    // 1. Obtener TODOS los productos de ESA tienda
    @GetMapping
    public ResponseEntity<List<ProductosResponse>> getAllByTienda(
            @PathVariable String nombreTienda) { // üëà Captura el slug
        
        return ResponseEntity.ok(this.productosService.readAllByTienda(nombreTienda));
    }

    // 2. Crear un producto en ESA tienda
    @PostMapping
    public ResponseEntity<ProductosResponse> postProductos(
            @PathVariable String nombreTienda, // üëà Captura el slug
            @Valid @RequestBody ProductosRequest request) {

        final var producto = this.productosService.create(nombreTienda, request);

        // Ajustamos la URI de respuesta para que incluya la tienda
        URI location = ServletUriComponentsBuilder
                .fromCurrentContextPath() // http://localhost:8080/ecommerce
                .path("/tienda/{nombreTienda}/productos/{id}")
                .buildAndExpand(nombreTienda, producto.getId())
                .toUri();

        return ResponseEntity.created(location).body(producto);
    }

    // 3. Buscar por nombre (dentro de la tienda)
    @GetMapping("/buscar")
    public ResponseEntity<List<ProductosResponse>> buscarProductos(
            @PathVariable String nombreTienda,
            @RequestParam("q") String termino) {

        return ResponseEntity.ok(this.productosService.buscarPorNombre(nombreTienda, termino));
    }

    // 4. Filtrar por categor√≠a (dentro de la tienda)
    @GetMapping("/categoria/{categoriaId}")
    public ResponseEntity<List<ProductosResponse>> buscarPorCategoria(
            @PathVariable String nombreTienda,
            @PathVariable Long categoriaId) {

        return ResponseEntity.ok(this.productosService.buscarPorCategoria(nombreTienda, categoriaId));
    }

    // --- M√©todos por ID (El ID es √∫nico global, pero la URL lleva la tienda por estructura) ---

    @GetMapping("/{id}")
    public ResponseEntity<ProductosResponse> getProductosById(
            @PathVariable String nombreTienda, // Se pide por la URL aunque no se use en el service readById
            @PathVariable Long id) {
        return ResponseEntity.ok(this.productosService.readById(id));
    }

    @PatchMapping("/{id}")
    public ResponseEntity<ProductosResponse> updateProductos(
            @PathVariable String nombreTienda,
            @PathVariable Long id,
            @RequestBody ProductosRequest request) {
        return ResponseEntity.ok(this.productosService.update(id, request));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteProductos(
            @PathVariable String nombreTienda,
            @PathVariable Long id) {
        this.productosService.delete(id);
        return ResponseEntity.noContent().build();
    }
}
package back.ecommerce.controllers;

import java.net.URI;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import back.ecommerce.dtos.TiendaRequest;
import back.ecommerce.dtos.TiendaResponse;
import back.ecommerce.services.TiendaService;
import jakarta.validation.Valid;
import lombok.AllArgsConstructor;

@RestController
@RequestMapping("/tiendas") // Endpoint base para gesti√≥n de tiendas
@CrossOrigin(origins = "*")
@AllArgsConstructor
public class TiendaController {

    private final TiendaService tiendaService;

    @PostMapping
    public ResponseEntity<TiendaResponse> crearTienda(@Valid @RequestBody TiendaRequest request) {
        var tiendaCreada = tiendaService.create(request);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{nombreUrl}")
                .buildAndExpand(tiendaCreada.getNombreUrl())
                .toUri();

        return ResponseEntity.created(location).body(tiendaCreada);
    }

    @GetMapping("/{nombreUrl}")
    public ResponseEntity<TiendaResponse> obtenerTienda(@PathVariable String nombreUrl) {
        return ResponseEntity.ok(tiendaService.readByNombreUrl(nombreUrl));
    }
}
package back.ecommerce.controllers;

import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import back.ecommerce.dtos.UsuariosRequest;
import back.ecommerce.dtos.UsuariosResponse;
import back.ecommerce.services.UsuariosService;
import lombok.AllArgsConstructor;


@RestController
@RequestMapping(path = "usuarios")
@CrossOrigin(origins = "*") 
@AllArgsConstructor
public class UsuariosController {

    private final UsuariosService usuariosService;

    @GetMapping()
    public ResponseEntity<List<UsuariosResponse>> obtenerTodosLosUsuarios() {
        return ResponseEntity.ok(usuariosService.readAll());
    }

    @GetMapping(path = "{dni}")
    public ResponseEntity<UsuariosResponse> getUsuarios(@PathVariable Long dni) {
       return ResponseEntity.ok(this.usuariosService.readByDni(dni));
    }
    
    @PatchMapping(path = "{dni}")
    public ResponseEntity<UsuariosResponse> actualizarUsuario(@PathVariable Long dni, @RequestBody UsuariosRequest request) {
        return ResponseEntity.ok(usuariosService.update(dni, request));
    }

    @DeleteMapping(path = "{dni}")
    public ResponseEntity<Void> eliminarUsuario(@PathVariable Long dni) {
        usuariosService.delete(dni);
        return ResponseEntity.noContent().build();
    }
}
package back.ecommerce.dtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AuthRequest {

    private String email;
    String password;
    
}
package back.ecommerce.dtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AuthResponse {
    private String token;
}
package back.ecommerce.dtos;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class CategoriasRequest {

    @NotBlank(message="El nombre de la categoria no puede estar vacio")
    private String nombre;

}
package back.ecommerce.dtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class CategoriasResponse {

    private Long id;
    private String nombre;

}
package back.ecommerce.dtos;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class ItemsPedidosRequest {

    @Min(value = 1, message = "La cantidad debe ser al menos 1")
    private int cantidad;

    @NotNull(message = "El ID del producto es obligatorio")
    private Long productoId;

}
package back.ecommerce.dtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class ItemsPedidosResponse {

    private int cantidad;
    private Double precioUnitario;
    private String nombreProducto;
    private String descripcionProducto;
    private Long idProducto;

}
package back.ecommerce.dtos;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class PedidosRequest {

    private Long id;
    private String estado;
    private Double total;
    private List<ItemsPedidosResponse> items;
    private Long usuarioDni;

}
package back.ecommerce.dtos;

import java.time.LocalDateTime;
import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class PedidosResponse {

    private Long id;
    private String estado;
    private Double total;
    private LocalDateTime fechaPedido;
    private List<ItemsPedidosResponse> items;
    private Long usuarioDni;

}
package back.ecommerce.dtos;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class ProductosRequest {

    private Long id;

    @NotNull(message = "El ID de la categor√≠a es obligatorio")
    private Long categoriaId;

    @NotBlank(message = "El nombre del producto es obligatorio")
    @Size(min = 3, max = 100, message = "El nombre debe tener entre 3 y 100 caracteres")
    private String nombre;

    // Descripci√≥n puede ser opcional, pero si est√°, que no sea gigante
    @Size(max = 500, message = "La descripci√≥n no puede superar los 500 caracteres")
    private String descripcion;

    @NotNull(message = "El precio es obligatorio")
    @Positive(message = "El precio debe ser mayor a cero")
    private Double precio;

    @NotNull(message = "El stock es obligatorio")
    @Min(value = 0, message = "El stock no puede ser negativo")
    private Integer stock;

    private String imagen;
}
package back.ecommerce.dtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class ProductosResponse {

    private Long id;
    private Long categoriaId;
    private String nombre;
    private String descripcion;
    private Double precio;
    private Integer stock;
    private String categoriaNombre;
    private String imagen;
}
package back.ecommerce.dtos;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class RegisterRequest {

    @NotNull(message = "El DNI es obligatorio")
    private Long dni;

    @NotBlank(message = "El nombre es obligatorio")
    private String nombre;

    @NotBlank(message = "El apellido es obligatorio")
    private String apellido;

    @NotBlank(message = "El email es obligatorio")
    @Email(message = "Formato de email inv√°lido")
    private String email;

    @NotBlank(message = "La contrase√±a es obligatoria")
    private String password;
    
    // Opcional: Podr√≠as recibir el ROL si quer√©s crear vendedores desde ac√°
    // private String rol; 
}
package back.ecommerce.dtos;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TiendaRequest {

    @NotBlank(message = "El nombre URL es obligatorio")
    @Pattern(regexp = "^[a-z0-9-]+$", message = "El nombre URL solo puede tener letras min√∫sculas, n√∫meros y guiones (ej: mi-tienda)")
    private String nombreUrl; // Ej: "la-ferreteria" (sin espacios)

    @NotBlank(message = "El nombre de fantas√≠a es obligatorio")
    private String nombreFantasia; // Ej: "La Ferreter√≠a de Juan"

    private String logo;
    private String descripcion;

    @NotNull(message = "El DNI del vendedor es obligatorio")
    private Long vendedorDni;
}
package back.ecommerce.dtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TiendaResponse {

    private Long id;
    private String nombreUrl;
    private String nombreFantasia;
    private String logo;
    private String descripcion;
    private Long vendedorDni;
    private String vendedorNombre;
    
}
package back.ecommerce.dtos;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class UsuariosRequest {
    
    @NotNull(message = "El DNI es obligatorio")
    private Long dni;

    @NotBlank(message = "El email es obligatorio")
    @Email(message = "El formato del email es inv√°lido (ejemplo@correo.com)")
    private String email;

    @NotBlank(message = "La contrase√±a es obligatoria")
    @Size(min = 6, message = "La contrase√±a debe tener al menos 6 caracteres")
    private String password;

    @NotBlank(message = "El nombre es obligatorio")
    private String nombre;

    @NotBlank(message = "El apellido es obligatorio")
    private String apellido;
}
package back.ecommerce.dtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class UsuariosResponse {

    private Long dni;
    private String email;
    private String nombre;
    private String apellido;

}
package back.ecommerce.entities;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonManagedReference;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "categorias")
@AllArgsConstructor
@NoArgsConstructor
public class CategoriasEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String nombre;

    @OneToMany(mappedBy = "categoria")
    @JsonManagedReference("categoria-producto")
    private List<ProductosEntity> productos;

    @ManyToOne
    @JoinColumn(name = "tienda_id")
    @JsonBackReference("tienda-categoria")
    private TiendaEntity tienda;
}
package back.ecommerce.entities;

import com.fasterxml.jackson.annotation.JsonBackReference;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "items_pedidos")
@AllArgsConstructor
@NoArgsConstructor
public class ItemsPedidosEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private int cantidad;
    private Double precioUnitario;

    @ManyToOne
    @JoinColumn(name = "pedido_id")
    @JsonBackReference("pedido-item")
    private PedidosEntity pedido;

    @ManyToOne
    @JoinColumn(name = "producto_id")
    @JsonBackReference("producto-item")
    private ProductosEntity producto;
}
package back.ecommerce.entities;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonManagedReference;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "pedidos")
@AllArgsConstructor
@NoArgsConstructor
public class PedidosEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private LocalDateTime fechaPedido;
    private String estado;
    private Double total;

    @ManyToOne
    @JoinColumn(name = "usuario_dni")
    @JsonBackReference("usuario-pedido")
    private UsuariosEntity usuario;

    @JsonManagedReference("pedido-item")
    @OneToMany(mappedBy = "pedido", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<ItemsPedidosEntity> itemsPedido;

    public void addItemPedido(ItemsPedidosEntity item) {
        if (this.itemsPedido == null) {
            this.itemsPedido = new ArrayList<>();
        }
        this.itemsPedido.add(item);
        item.setPedido(this);
    }

    public void removeItemPedido(ItemsPedidosEntity item) {
        if (this.itemsPedido != null) {
            this.itemsPedido.remove(item);
            item.setPedido(null);
        }
    } 

    @ManyToOne
    @JoinColumn(name = "tienda_id")
    @JsonBackReference("tienda-pedido")
    private TiendaEntity tienda;
}
package back.ecommerce.entities;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonBackReference; // <-- IMPORT
import com.fasterxml.jackson.annotation.JsonManagedReference;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne; // <-- IMPORT
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter; // <-- IMPORT

@Getter
@Setter
@Entity
@Table(name = "productos")
@AllArgsConstructor
@NoArgsConstructor
public class ProductosEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nombre;
    private String descripcion;
    private Double precio;
    private Integer stock;
    private String imagen;
    
    @ManyToOne
    @JoinColumn(name = "categoria_id")
    @JsonBackReference("categoria-producto")
    private CategoriasEntity categoria;

    @OneToMany(mappedBy = "producto")
    @JsonManagedReference("producto-item")
    private List<ItemsPedidosEntity> itemsPedido;

    // ‚úÖ NUEVO: A qu√© tienda pertenece
    @ManyToOne
    @JoinColumn(name = "tienda_id")
    @JsonBackReference("tienda-producto")
    private TiendaEntity tienda;
}
package back.ecommerce.entities;

public enum Rol {
    COMPRADOR,
    VENDEDOR,
    ADMIN_PLATAFORMA // (Opcional, por si ustedes quieren entrar a ver todo)
}
package back.ecommerce.entities;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonManagedReference;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "tiendas")
@AllArgsConstructor
@NoArgsConstructor
public class TiendaEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String nombreUrl; // El "slug" (ej: "tienda-de-juan")

    private String nombreFantasia; // El nombre lindo (ej: "La Tienda de Juan")
    private String logo; // URL de la imagen
    private String descripcion;

    // Relaci√≥n con el DUE√ëO (Vendedor)
    @OneToOne
    @JoinColumn(name = "vendedor_dni")
    private UsuariosEntity vendedor;

    // Relaci√≥n con sus PRODUCTOS
    @OneToMany(mappedBy = "tienda", cascade = CascadeType.ALL)
    @JsonManagedReference("tienda-producto")
    private List<ProductosEntity> productos;

    // Relaci√≥n con sus CATEGOR√çAS
    @OneToMany(mappedBy = "tienda", cascade = CascadeType.ALL)
    @JsonManagedReference("tienda-categoria")
    private List<CategoriasEntity> categorias;
    
    // Relaci√≥n con sus PEDIDOS
    @OneToMany(mappedBy = "tienda")
    @JsonManagedReference("tienda-pedido")
    private List<PedidosEntity> pedidos;
}
package back.ecommerce.entities;

import java.util.Collection;
import java.util.List;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import com.fasterxml.jackson.annotation.JsonManagedReference;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "usuarios")
public class UsuariosEntity implements UserDetails {

    @Id
    private Long dni;
    private String email;
    private String password;
    private String nombre;
    private String apellido;

    @Enumerated(EnumType.STRING)
    private Rol rol; // Asegurate de tener el Enum Rol creado

    @Column(columnDefinition = "boolean default false")
    private boolean emailVerificado; 
    
    private String verificationCode; // El c√≥digo UUID que va en el link

    @OneToMany(mappedBy = "usuario")
    @JsonManagedReference("usuario-pedido")
    private List<PedidosEntity> pedidos;

    // --- M√âTODOS DE USER DETAILS (OBLIGATORIOS) ---

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(new SimpleGrantedAuthority(rol.name()));
    }

    @Override
    public String getUsername() {
        return email; // Usamos el email como usuario
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public boolean isAccountNonExpired() { return true; }

    @Override
    public boolean isAccountNonLocked() { return true; }

    @Override
    public boolean isCredentialsNonExpired() { return true; }

    @Override
    public boolean isEnabled() { return true; }
}
package back.ecommerce.repositories;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import back.ecommerce.entities.CategoriasEntity;

public interface CategoriasRepository extends JpaRepository<CategoriasEntity, Long>{



    // Traer todas las categor√≠as DE ESA TIENDA
    List<CategoriasEntity> findByTiendaNombreUrl(String nombreUrl);

}
package back.ecommerce.repositories;

import org.springframework.data.jpa.repository.JpaRepository;

import back.ecommerce.entities.ItemsPedidosEntity;

public interface ItemsPedidosRepository extends JpaRepository<ItemsPedidosEntity, Long>{

}
package back.ecommerce.repositories;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import back.ecommerce.entities.PedidosEntity;

public interface PedidosRepository extends JpaRepository<PedidosEntity, Long>{

    // Ver todos los pedidos recibidos por UNA TIENDA (para el panel del vendedor)
    List<PedidosEntity> findByTiendaNombreUrl(String nombreUrl);

    // Ver los pedidos que hizo UN COMPRADOR en una tienda espec√≠fica
    List<PedidosEntity> findByTiendaNombreUrlAndUsuarioDni(String nombreUrl, Long dni);

}
package back.ecommerce.repositories;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import back.ecommerce.entities.ProductosEntity;

public interface ProductosRepository extends JpaRepository<ProductosEntity, Long>{

    // Buscar productos de una tienda espec√≠fica (usando el slug de la URL)
    List<ProductosEntity> findByTiendaNombreUrl(String nombreUrl);

    // Buscar por nombre, PERO solo dentro de esa tienda (para que no busque en otras)
    List<ProductosEntity> findByTiendaNombreUrlAndNombreContainingIgnoreCase(String nombreUrl, String termino);

    // Filtrar por categor√≠a, PERO solo dentro de esa tienda
    List<ProductosEntity> findByTiendaNombreUrlAndCategoriaId(String nombreUrl, Long categoriaId);

}
package back.ecommerce.repositories;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;

import back.ecommerce.entities.TiendaEntity;

public interface TiendaRepository extends JpaRepository<TiendaEntity, Long> {
    // Buscar tienda por su "slug" (ej: "juan")
    Optional<TiendaEntity> findByNombreUrl(String nombreUrl);
}
package back.ecommerce.repositories;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;

import back.ecommerce.entities.UsuariosEntity;

public interface UsuariosRepository extends JpaRepository<UsuariosEntity, Long>{

    Optional<UsuariosEntity> findByEmail(String email);

    Optional<UsuariosEntity> findByVerificationCode(String verificationCode);
    
}
package back.ecommerce.services;

import java.util.UUID;

import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import back.ecommerce.dtos.AuthRequest;
import back.ecommerce.dtos.AuthResponse;
import back.ecommerce.dtos.RegisterRequest;
import back.ecommerce.entities.Rol;
import back.ecommerce.entities.UsuariosEntity;
import back.ecommerce.repositories.UsuariosRepository;
import lombok.RequiredArgsConstructor; // Para generar el c√≥digo √∫nico

@Service
@RequiredArgsConstructor
public class AuthService {

    private final UsuariosRepository usuariosRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;
    private final AuthenticationManager authenticationManager;
    private final EmailService emailService; // ‚úÖ Inyectamos EmailService

    public AuthResponse register(RegisterRequest request) {
        if (usuariosRepository.existsById(request.getDni())) {
            throw new IllegalArgumentException("Ya existe un usuario con el DNI " + request.getDni());
        }
        if (usuariosRepository.findByEmail(request.getEmail()).isPresent()) {
            throw new IllegalArgumentException("El email " + request.getEmail() + " ya est√° registrado");
        }

        // Generamos c√≥digo de verificaci√≥n
        String codigoVerificacion = UUID.randomUUID().toString();

        var user = UsuariosEntity.builder()
                .dni(request.getDni())
                .nombre(request.getNombre())
                .apellido(request.getApellido())
                .email(request.getEmail())
                .password(passwordEncoder.encode(request.getPassword()))
                .rol(Rol.COMPRADOR)
                .emailVerificado(false) // ‚úÖ Nace NO verificado
                .verificationCode(codigoVerificacion) // ‚úÖ Guardamos el c√≥digo
                .build();

        usuariosRepository.save(user);

        // ‚úÖ ENVIAR EL MAIL
        // (En prod esto ser√≠a la URL de tu frontend o backend en Render)
        String link = "http://localhost:8080/ecommerce/auth/verify?code=" + codigoVerificacion;
        
        String mensaje = "Hola " + user.getNombre() + "!\n\n" +
                         "Para activar tu cuenta de vendedor, hac√© clic ac√°:\n" +
                         link + "\n\n" +
                         "Si no solicitaste esto, ignor√° este mensaje.";

        emailService.enviarCorreo(user.getEmail(), "Verific√° tu cuenta", mensaje);

        // Retornamos token (aunque no pueda crear tiendas todav√≠a, puede loguearse)
        var jwtToken = jwtService.generateToken(user);
        return AuthResponse.builder().token(jwtToken).build();
    }

    public AuthResponse login(AuthRequest request) {
        authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword())
        );
        var user = usuariosRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> new IllegalArgumentException("Usuario o contrase√±a incorrectos"));

        var jwtToken = jwtService.generateToken(user);
        return AuthResponse.builder().token(jwtToken).build();
    }

    // ‚úÖ NUEVO M√âTODO PARA VALIDAR
    public String verifyUser(String code) {
        UsuariosEntity user = usuariosRepository.findByVerificationCode(code)
                .orElseThrow(() -> new IllegalArgumentException("C√≥digo de verificaci√≥n inv√°lido o expirado"));

        if (user.isEmailVerificado()) {
            return "Tu cuenta ya estaba verificada.";
        }

        user.setEmailVerificado(true);
        user.setVerificationCode(null); // Borramos el c√≥digo por seguridad
        usuariosRepository.save(user);

        return "¬°Cuenta verificada con √©xito! Ahora pod√©s crear tu tienda.";
    }
}
package back.ecommerce.services;

import java.util.List;

import back.ecommerce.dtos.CategoriasRequest;
import back.ecommerce.dtos.CategoriasResponse;

public interface CategoriasService {

    // Crear una categor√≠a asignada a una tienda espec√≠fica
    CategoriasResponse create(String nombreTienda, CategoriasRequest request);

    // Leer todas las categor√≠as de una tienda espec√≠fica
    List<CategoriasResponse> readAllByTienda(String nombreTienda);

    // M√©todos por ID (Siguen igual porque el ID es √∫nico)
    CategoriasResponse readById(Long id);
    CategoriasResponse update(Long id, CategoriasRequest request);
    void delete(Long id);
}
package back.ecommerce.services;

import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.BeanUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional; // üëà Importante

import back.ecommerce.dtos.CategoriasRequest;
import back.ecommerce.dtos.CategoriasResponse;
import back.ecommerce.entities.CategoriasEntity;
import back.ecommerce.repositories.CategoriasRepository;
import back.ecommerce.repositories.TiendaRepository;
import lombok.AllArgsConstructor;

@Service
@Transactional
@AllArgsConstructor
public class CategoriasServiceImpl implements CategoriasService {

    private final CategoriasRepository categoriasRepository;
    private final TiendaRepository tiendaRepository; // üëà Inyecci√≥n del repo de tiendas

    @Override
    public CategoriasResponse create(String nombreTienda, CategoriasRequest request) {
        // 1. Buscamos la TIENDA por su slug (URL)
        var tienda = tiendaRepository.findByNombreUrl(nombreTienda)
                .orElseThrow(() -> new IllegalArgumentException("Tienda no encontrada: " + nombreTienda));

        // 2. Creamos la entidad Categor√≠a
        var entity = new CategoriasEntity();
        entity.setNombre(request.getNombre());
        
        // 3. La vinculamos a la tienda
        entity.setTienda(tienda);

        // 4. Guardamos
        var categoriaGuardada = categoriasRepository.save(entity);
        
        return convertirEntidadAResponse(categoriaGuardada);
    }

    @Override
    public List<CategoriasResponse> readAllByTienda(String nombreTienda) {
        // Usamos el m√©todo del repositorio que filtra por tienda
        return categoriasRepository.findByTiendaNombreUrl(nombreTienda).stream()
                .map(this::convertirEntidadAResponse)
                .collect(Collectors.toList());
    }

    @Override
    public CategoriasResponse readById(Long id) {
        var entity = categoriasRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Categor√≠a no encontrada con id: " + id));
        return convertirEntidadAResponse(entity);
    }

    @Override
    public CategoriasResponse update(Long id, CategoriasRequest request) {
        var entity = categoriasRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Categor√≠a no encontrada con id: " + id));

        if (request.getNombre() != null && !request.getNombre().isBlank()) {
            entity.setNombre(request.getNombre());
        }

        var categoriaActualizada = categoriasRepository.save(entity);
        return convertirEntidadAResponse(categoriaActualizada);
    }

    @Override
    public void delete(Long id) {
        var entity = categoriasRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Categor√≠a no encontrada con id: " + id));
        categoriasRepository.delete(entity);
    }

    // --- Helper para convertir Entidad a DTO ---
    private CategoriasResponse convertirEntidadAResponse(CategoriasEntity entity) {
        var response = new CategoriasResponse();
        BeanUtils.copyProperties(entity, response);
        return response;
    }
}
package back.ecommerce.services;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
public class EmailService {

    @Autowired
    private JavaMailSender mailSender;

    @Value("${spring.mail.username}")
    private String fromEmail;

    public void enviarCorreo(String to, String subject, String body) {
        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(fromEmail);
            message.setTo(to);
            message.setSubject(subject);
            message.setText(body);

            mailSender.send(message);
            log.info("üìß Email enviado correctamente a: {}", to);
        } catch (Exception e) {
            log.error("‚ùå Error enviando email a {}: {}", to, e.getMessage());
        }
    }
}
package back.ecommerce.services;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

import org.springframework.beans.factory.annotation.Value; // Importar Value
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;

@Service
public class JwtService {

    // ‚úÖ CAMBIO: Inyectamos la clave desde application.properties
    @Value("${jwt.secret.key}")
    private String secretKey;

    public String generateToken(UserDetails userDetails) {
        return generateToken(new HashMap<>(), userDetails);
    }

    public String generateToken(Map<String, Object> extraClaims, UserDetails userDetails) {
        return Jwts.builder()
                .setClaims(extraClaims)
                .setSubject(userDetails.getUsername())
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 24))
                .signWith(getSignInKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public boolean isTokenValid(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername())) && !isTokenExpired(token);
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSignInKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    private Key getSignInKey() {
        // ‚úÖ CAMBIO: Usamos la variable 'secretKey' inyectada en lugar de la constante
        byte[] keyBytes = Decoders.BASE64.decode(secretKey);
        return Keys.hmacShaKeyFor(keyBytes);
    }
}
package back.ecommerce.services;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import org.springframework.beans.factory.annotation.Value; // Importar Value
import org.springframework.stereotype.Service;

import com.mercadopago.MercadoPagoConfig;
import com.mercadopago.client.payment.PaymentClient;
import com.mercadopago.client.preference.PreferenceBackUrlsRequest;
import com.mercadopago.client.preference.PreferenceClient;
import com.mercadopago.client.preference.PreferenceItemRequest;
import com.mercadopago.client.preference.PreferenceRequest;
import com.mercadopago.exceptions.MPApiException;
import com.mercadopago.resources.payment.Payment;
import com.mercadopago.resources.preference.Preference;

import back.ecommerce.entities.PedidosEntity;
import back.ecommerce.repositories.PedidosRepository;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class MercadoPagoService {

    // ‚úÖ CAMBIO: Inyecci√≥n de propiedades
    @Value("${mp.access.token}")
    private String accessToken;

    @Value("${app.backend.url}")
    private String backendUrl;
    
    @Value("${app.frontend.url}")
    private String frontendUrl;

    private final PedidosRepository pedidosRepository;

    public String crearPreferencia(PedidosEntity pedido) {
        // Usamos el token inyectado
        MercadoPagoConfig.setAccessToken(accessToken);

        List<PreferenceItemRequest> items = new ArrayList<>();
        pedido.getItemsPedido().forEach(item -> {
            PreferenceItemRequest itemRequest = PreferenceItemRequest.builder()
                    .title(item.getProducto().getNombre())
                    .quantity(item.getCantidad())
                    .unitPrice(BigDecimal.valueOf(item.getPrecioUnitario()))
                    .currencyId("ARS")
                    .build();
            items.add(itemRequest);
        });

        // Usamos la URL del frontend inyectada
        PreferenceBackUrlsRequest backUrls = PreferenceBackUrlsRequest.builder()
                .success(frontendUrl + "/compra-exitosa")
                .failure(frontendUrl + "/compra-fallida")
                .pending(frontendUrl + "/compra-pendiente")
                .build();

        PreferenceRequest preferenceRequest = PreferenceRequest.builder()
                .items(items)
                .backUrls(backUrls)
                .autoReturn("approved")
                .externalReference(String.valueOf(pedido.getId()))
                // Usamos la URL del backend inyectada
                .notificationUrl(backendUrl + "/api/pagos/webhook")
                .build();

        try {
            PreferenceClient client = new PreferenceClient();
            Preference preference = client.create(preferenceRequest);
            return preference.getInitPoint();

        } catch (MPApiException e) {
            System.err.println("‚ùå ERROR MP: " + e.getApiResponse().getContent());
            throw new RuntimeException("Error de MP", e);
        } catch (Exception e) {
            throw new RuntimeException("Error general", e);
        }
    }
    
    public void procesarNotificacion(Long paymentId) {
        try {
            // Aseguramos el token tambi√©n aqu√≠
            MercadoPagoConfig.setAccessToken(accessToken);
            
            PaymentClient client = new PaymentClient();
            Payment payment = client.get(paymentId);

            if ("approved".equals(payment.getStatus())) {
                String externalReference = payment.getExternalReference();
                Long pedidoId = Long.parseLong(externalReference);

                PedidosEntity pedido = pedidosRepository.findById(pedidoId)
                        .orElseThrow(() -> new RuntimeException("Pedido no encontrado"));
                
                if (!"PAGADO".equals(pedido.getEstado())) {
                    pedido.setEstado("PAGADO");
                    pedidosRepository.save(pedido);
                }
            }
        } catch (Exception e) {
            System.err.println("Error procesando notificaci√≥n: " + e.getMessage());
        }
    } 
}
package back.ecommerce.services;

import java.util.List;

import back.ecommerce.dtos.PedidosRequest;
import back.ecommerce.dtos.PedidosResponse;

public interface PedidosService {

    // Crear pedido EN una tienda espec√≠fica
    PedidosResponse create(String nombreTienda, PedidosRequest request);

    // Ver pedidos DE una tienda (para el vendedor)
    List<PedidosResponse> readAllByTienda(String nombreTienda);

    // Ver pedidos de un USUARIO en una tienda espec√≠fica
    List<PedidosResponse> findByUsuarioDni(String nombreTienda, Long dni);

    // M√©todos por ID (igual que siempre)
    PedidosResponse readById(Long id);
    PedidosResponse update(Long id, PedidosRequest request);
    void delete(Long id);
}
package back.ecommerce.services;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.BeanUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import back.ecommerce.dtos.ItemsPedidosResponse;
import back.ecommerce.dtos.PedidosRequest;
import back.ecommerce.dtos.PedidosResponse;
import back.ecommerce.entities.ItemsPedidosEntity;
import back.ecommerce.entities.PedidosEntity;
import back.ecommerce.repositories.PedidosRepository;
import back.ecommerce.repositories.ProductosRepository;
import back.ecommerce.repositories.TiendaRepository;
import back.ecommerce.repositories.UsuariosRepository;
import lombok.AllArgsConstructor;

@Service
@Transactional
@AllArgsConstructor
public class PedidosServiceImpl implements PedidosService {

    private final PedidosRepository pedidosRepository;
    private final UsuariosRepository usuariosRepository;
    private final ProductosRepository productosRepository;
    private final TiendaRepository tiendaRepository;

    @Override
    public PedidosResponse create(String nombreTienda, PedidosRequest pedidoRequest) {
        
        // 1. Buscamos la TIENDA
        var tienda = tiendaRepository.findByNombreUrl(nombreTienda)
                .orElseThrow(() -> new IllegalArgumentException("Tienda no encontrada: " + nombreTienda));

        // 2. Buscamos el Usuario
        var usuario = usuariosRepository.findById(pedidoRequest.getUsuarioDni())
                .orElseThrow(() -> new IllegalArgumentException("Usuario no encontrado con DNI: " + pedidoRequest.getUsuarioDni()));

        // 3. Armamos el Pedido base
        var pedidoEntity = new PedidosEntity();
        pedidoEntity.setUsuario(usuario);
        pedidoEntity.setTienda(tienda);
        pedidoEntity.setFechaPedido(LocalDateTime.now());
        pedidoEntity.setEstado("PENDIENTE");
        pedidoEntity.setItemsPedido(new ArrayList<>());

        BigDecimal totalCalculado = BigDecimal.ZERO;

        // 4. Procesamos Items
        if (pedidoRequest.getItems() != null && !pedidoRequest.getItems().isEmpty()) {
            for (var itemReq : pedidoRequest.getItems()) {
                var producto = productosRepository.findById(itemReq.getIdProducto())
                        .orElseThrow(() -> new IllegalArgumentException("Producto no encontrado con id: " + itemReq.getIdProducto()));

                // ‚úÖ VALIDACI√ìN A: Coherencia de Tienda
                // Verificamos que el producto pertenezca a la tienda donde se est√° comprando
                if (!producto.getTienda().getId().equals(tienda.getId())) {
                    throw new IllegalArgumentException("El producto '" + producto.getNombre() + "' no pertenece a la tienda '" + nombreTienda + "'");
                }

                // ‚úÖ VALIDACI√ìN B: Control de Stock
                if (producto.getStock() < itemReq.getCantidad()) {
                    throw new IllegalArgumentException("Stock insuficiente para el producto: " + producto.getNombre() + ". Disponible: " + producto.getStock());
                }

                // ‚úÖ ACCI√ìN: Descontar Stock
                producto.setStock(producto.getStock() - itemReq.getCantidad());
                productosRepository.save(producto); // Guardamos el producto con el nuevo stock

                // Crear el Item del Pedido
                var itemEntity = new ItemsPedidosEntity();
                itemEntity.setCantidad(itemReq.getCantidad());
                itemEntity.setProducto(producto);
                itemEntity.setPrecioUnitario(producto.getPrecio());
                itemEntity.setPedido(pedidoEntity);
                
                pedidoEntity.getItemsPedido().add(itemEntity);

                // Calcular total
                BigDecimal cantidad = new BigDecimal(itemReq.getCantidad());
                BigDecimal subtotal = BigDecimal.valueOf(producto.getPrecio()).multiply(cantidad);
                totalCalculado = totalCalculado.add(subtotal);
            }
        }

        pedidoEntity.setTotal(totalCalculado.doubleValue());
        var pedidoGuardado = pedidosRepository.save(pedidoEntity);

        return convertirEntidadAResponse(pedidoGuardado);
    }

    @Override
    public List<PedidosResponse> readAllByTienda(String nombreTienda) {
        return pedidosRepository.findByTiendaNombreUrl(nombreTienda).stream()
                .map(this::convertirEntidadAResponse)
                .collect(Collectors.toList());
    }

    @Override
    public List<PedidosResponse> findByUsuarioDni(String nombreTienda, Long dni) {
        return pedidosRepository.findByTiendaNombreUrlAndUsuarioDni(nombreTienda, dni).stream()
                .map(this::convertirEntidadAResponse)
                .collect(Collectors.toList());
    }

    @Override
    public PedidosResponse readById(Long id) {
        var entity = pedidosRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Pedido no encontrado: " + id));
        return convertirEntidadAResponse(entity);
    }

    @Override
    public PedidosResponse update(Long id, PedidosRequest pedidoRequest) {
        var entityFromDB = pedidosRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Pedido no encontrado: " + id));

        if (pedidoRequest.getEstado() != null && !pedidoRequest.getEstado().isBlank()) {
            entityFromDB.setEstado(pedidoRequest.getEstado());
        }

        return convertirEntidadAResponse(pedidosRepository.save(entityFromDB));
    }

    @Override
    public void delete(Long id) {
        var entity = pedidosRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Pedido no encontrado: " + id));
        pedidosRepository.delete(entity);
    }

    // --- Helper ---
    private PedidosResponse convertirEntidadAResponse(PedidosEntity entidad) {
        var response = new PedidosResponse();
        BeanUtils.copyProperties(entidad, response);
        
        if (entidad.getUsuario() != null) {
            response.setUsuarioDni(entidad.getUsuario().getDni());
        }

        if (entidad.getItemsPedido() != null) {
            List<ItemsPedidosResponse> itemsDto = entidad.getItemsPedido().stream().map(item -> {
                ItemsPedidosResponse dto = new ItemsPedidosResponse();
                dto.setCantidad(item.getCantidad());
                dto.setPrecioUnitario(item.getPrecioUnitario());
                if (item.getProducto() != null) {
                    dto.setIdProducto(item.getProducto().getId());
                    dto.setNombreProducto(item.getProducto().getNombre());
                    dto.setDescripcionProducto(item.getProducto().getDescripcion());
                }
                return dto;
            }).collect(Collectors.toList());
            response.setItems(itemsDto);
        } else {
            response.setItems(Collections.emptyList());
        }
        return response;
    }
}
package back.ecommerce.services;

import java.util.List;

import back.ecommerce.dtos.ProductosRequest;
import back.ecommerce.dtos.ProductosResponse;

public interface ProductosService {
    
    // Crear asignando a una tienda
    ProductosResponse create(String nombreTienda, ProductosRequest producto);

    // Leer solo los de esa tienda
    List<ProductosResponse> readAllByTienda(String nombreTienda);

    // B√∫squedas filtradas por tienda
    List<ProductosResponse> buscarPorNombre(String nombreTienda, String termino);
    List<ProductosResponse> buscarPorCategoria(String nombreTienda, Long categoriaId);

    // M√©todos por ID (Siguen igual porque el ID es √∫nico global)
    ProductosResponse readById(Long id);
    ProductosResponse update(Long id, ProductosRequest producto);
    void delete(Long id);
    
}
package back.ecommerce.services;

import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.BeanUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import back.ecommerce.dtos.ProductosRequest; // üëà Importante
import back.ecommerce.dtos.ProductosResponse;
import back.ecommerce.entities.ProductosEntity;
import back.ecommerce.repositories.CategoriasRepository;
import back.ecommerce.repositories.ProductosRepository;
import back.ecommerce.repositories.TiendaRepository;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Transactional
@Slf4j
@AllArgsConstructor
public class ProductosServiceImpl implements ProductosService {

    private final ProductosRepository productosRepository;
    private final CategoriasRepository categoriasRepository;
    private final TiendaRepository tiendaRepository; // üëà Nuevo repo inyectado

    @Override
    public ProductosResponse create(String nombreTienda, ProductosRequest productoRequest) {
        // 1. Buscamos la TIENDA
        var tienda = tiendaRepository.findByNombreUrl(nombreTienda)
                .orElseThrow(() -> new IllegalArgumentException("Tienda no encontrada: " + nombreTienda));

        // 2. Creamos la entidad
        var entity = new ProductosEntity();
        BeanUtils.copyProperties(productoRequest, entity);

        // 3. Buscamos y asignamos la categor√≠a
        var categoria = categoriasRepository.findById(productoRequest.getCategoriaId())
            .orElseThrow(() -> new IllegalArgumentException("Categoria no encontrada con id: " + productoRequest.getCategoriaId()));
        entity.setCategoria(categoria);

        // 4. Asignamos la tienda a la entidad
        entity.setTienda(tienda); 

        // 5. Guardamos
        var productoCreated = productosRepository.save(entity);

        return convertirEntidadAResponse(productoCreated);
    }

    @Override
    public List<ProductosResponse> readAllByTienda(String nombreTienda) {
        // Usamos el m√©todo del repositorio que filtra por la URL de la tienda
        return productosRepository.findByTiendaNombreUrl(nombreTienda)
                .stream()
                .map(this::convertirEntidadAResponse)
                .collect(Collectors.toList());
    }

    @Override
    public List<ProductosResponse> buscarPorNombre(String nombreTienda, String termino) {
        // Buscamos por nombre PERO solo dentro de esa tienda
        return productosRepository.findByTiendaNombreUrlAndNombreContainingIgnoreCase(nombreTienda, termino)
                .stream()
                .map(this::convertirEntidadAResponse)
                .collect(Collectors.toList());
    }

    @Override
    public List<ProductosResponse> buscarPorCategoria(String nombreTienda, Long categoriaId) {
        // Filtramos por categor√≠a PERO solo dentro de esa tienda
        return productosRepository.findByTiendaNombreUrlAndCategoriaId(nombreTienda, categoriaId)
                .stream()
                .map(this::convertirEntidadAResponse)
                .collect(Collectors.toList());
    }

    // --- M√©todos por ID (Mantenemos la l√≥gica original) ---

    @Override
    public ProductosResponse readById(Long id) {
        final var entityResponse = this.productosRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Producto no encontrado con id: " + id));
        return convertirEntidadAResponse(entityResponse);
    }

    @Override
    public ProductosResponse update(Long id, ProductosRequest productoRequest) {
        final var entityFromDB = this.productosRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Producto no encontrado con id: " + id));

        if (productoRequest.getNombre() != null && !productoRequest.getNombre().isBlank()) {
            entityFromDB.setNombre(productoRequest.getNombre());
        }
        if (productoRequest.getDescripcion() != null) {
            entityFromDB.setDescripcion(productoRequest.getDescripcion());
        }
        if (productoRequest.getPrecio() != null) {
            entityFromDB.setPrecio(productoRequest.getPrecio());
        }
        if (productoRequest.getStock() != null) {
            entityFromDB.setStock(productoRequest.getStock());
        }
        if (productoRequest.getImagen() != null) {
            entityFromDB.setImagen(productoRequest.getImagen());
        }
        if (productoRequest.getCategoriaId() != null) {
            var categoria = categoriasRepository.findById(productoRequest.getCategoriaId())
                .orElseThrow(() -> new IllegalArgumentException("Categor√≠a no encontrada con id: " + productoRequest.getCategoriaId()));
            entityFromDB.setCategoria(categoria);
        }
        
        var productoActualizado = this.productosRepository.save(entityFromDB);
        return convertirEntidadAResponse(productoActualizado);
    }

    @Override
    public void delete(Long id) {
        var producto = this.productosRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Producto no encontrado con id: " + id));
        
        log.info("Eliminando producto: {}", producto.getNombre());
        this.productosRepository.delete(producto);
    }

    // --- Helper ---
    private ProductosResponse convertirEntidadAResponse(ProductosEntity entidad) {
        var response = new ProductosResponse();
        BeanUtils.copyProperties(entidad, response);

        if (entidad.getCategoria() != null) {
            response.setCategoriaId(entidad.getCategoria().getId());
            response.setCategoriaNombre(entidad.getCategoria().getNombre());
        }
        
        return response;
    }
}
package back.ecommerce.services;

import back.ecommerce.dtos.TiendaRequest;
import back.ecommerce.dtos.TiendaResponse;

public interface TiendaService {
    
    TiendaResponse create(TiendaRequest request);
    
    TiendaResponse readByNombreUrl(String nombreUrl);
    
    // Pod√©s agregar update y delete a futuro
}
package back.ecommerce.services;

import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Value; // Importar Value
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import back.ecommerce.dtos.TiendaRequest;
import back.ecommerce.dtos.TiendaResponse;
import back.ecommerce.entities.TiendaEntity;
import back.ecommerce.repositories.TiendaRepository;
import back.ecommerce.repositories.UsuariosRepository;
import lombok.RequiredArgsConstructor; // Cambiado a RequiredArgsConstructor para facilitar el uso de @Value

@Service
@Transactional
@RequiredArgsConstructor // Usamos este en lugar de AllArgsConstructor para permitir campos no-finales con @Value si es necesario, o mantenemos la estructura
public class TiendaServiceImpl implements TiendaService {

    private final TiendaRepository tiendaRepository;
    private final UsuariosRepository usuariosRepository;
    private final EmailService emailService;

    // ‚úÖ CAMBIO: Inyecci√≥n de la URL del frontend para los emails
    @Value("${app.frontend.url}")
    private String frontendUrl;

    @Override
    public TiendaResponse create(TiendaRequest request) {
        var vendedor = usuariosRepository.findById(request.getVendedorDni())
                .orElseThrow(() -> new IllegalArgumentException("Vendedor no encontrado con DNI: " + request.getVendedorDni()));

        if (!vendedor.isEmailVerificado()) {
             throw new IllegalStateException("Debes verificar tu email antes de crear una tienda. Revis√° tu correo para activarla.");
        }

        if (tiendaRepository.findByNombreUrl(request.getNombreUrl()).isPresent()) {
            throw new IllegalArgumentException("La URL de tienda '" + request.getNombreUrl() + "' ya est√° en uso.");
        }

        var entity = new TiendaEntity();
        BeanUtils.copyProperties(request, entity);
        entity.setVendedor(vendedor);

        var tiendaGuardada = tiendaRepository.save(entity);
        
        String asunto = "¬°Tu tienda '" + tiendaGuardada.getNombreFantasia() + "' est√° lista!";
        
        // Usamos la variable inyectada en lugar de texto fijo
        String mensaje = "Hola " + vendedor.getNombre() + ",\n\n" +
                         "Felicitaciones, ya creamos tu espacio en nuestra plataforma.\n" +
                         "Pod√©s acceder a tu panel de administraci√≥n y empezar a cargar productos.\n\n" +
                         "Tu URL p√∫blica es: " + frontendUrl + "/tienda/" + tiendaGuardada.getNombreUrl() + "\n\n" +
                         "√âxitos,\nEl equipo de Ecommerce.";

        emailService.enviarCorreo(vendedor.getEmail(), asunto, mensaje);
        
        return convertirEntidadAResponse(tiendaGuardada);
    }

    @Override
    public TiendaResponse readByNombreUrl(String nombreUrl) {
        var entity = tiendaRepository.findByNombreUrl(nombreUrl)
                .orElseThrow(() -> new IllegalArgumentException("Tienda no encontrada: " + nombreUrl));
        
        return convertirEntidadAResponse(entity);
    }

    private TiendaResponse convertirEntidadAResponse(TiendaEntity entity) {
        return TiendaResponse.builder()
                .id(entity.getId())
                .nombreUrl(entity.getNombreUrl())
                .nombreFantasia(entity.getNombreFantasia())
                .logo(entity.getLogo())
                .descripcion(entity.getDescripcion())
                .vendedorDni(entity.getVendedor() != null ? entity.getVendedor().getDni() : null)
                .vendedorNombre(entity.getVendedor() != null ? entity.getVendedor().getNombre() : null)
                .build();
    }
}
package back.ecommerce.services;

import java.util.List;

import back.ecommerce.dtos.UsuariosRequest;
import back.ecommerce.dtos.UsuariosResponse;

public interface UsuariosService {
    
    //Obtener todos
    List<UsuariosResponse> readAll();

    //Obtener por id
    UsuariosResponse readByDni(Long dni);

    //Actualizar
    UsuariosResponse update(Long dni, UsuariosRequest usuario);
    
    //Eliminar
    void delete(Long dni);

}
package back.ecommerce.services;

import java.util.List;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import back.ecommerce.dtos.UsuariosRequest;
import back.ecommerce.dtos.UsuariosResponse;
import back.ecommerce.entities.UsuariosEntity;
import back.ecommerce.repositories.UsuariosRepository;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Transactional
@Slf4j
@AllArgsConstructor
public class UsuariosServiceImpl implements UsuariosService {

    private final UsuariosRepository usuariosRepository;

    @Override
    public List<UsuariosResponse> readAll() {
        return usuariosRepository.findAll().stream()
                .map(this::convertirEntidadAResponse)
                .collect(Collectors.toList());
    }

    @Override
    public UsuariosResponse readByDni(Long dni) {
        final var entityResponse = this.usuariosRepository.findById(dni)
            .orElseThrow(() -> new IllegalArgumentException("No existe el usuario con id: " + dni));
        
        return convertirEntidadAResponse(entityResponse);
    }

    @Override
    public UsuariosResponse update(Long dni, UsuariosRequest request) {
        final var entidad = this.usuariosRepository.findById(dni)
            .orElseThrow(() -> new IllegalArgumentException("Usuario no encontrado con DNI: " + dni));

        if (request.getNombre() != null && !request.getNombre().isBlank()) {
            entidad.setNombre(request.getNombre());
        }
        if (request.getApellido() != null && !request.getApellido().isBlank()) {
            entidad.setApellido(request.getApellido());
        }
        if (request.getEmail() != null && !request.getEmail().isBlank()) {
            entidad.setEmail(request.getEmail());
        }
        if (request.getPassword() != null && !request.getPassword().isBlank()) {
            // encriptar la password antes de guardarla (por hacer)
            entidad.setPassword(request.getPassword());
        }

        var usuarioActualizado = usuariosRepository.save(entidad);
        return convertirEntidadAResponse(usuarioActualizado);
    }

    @Override
    public void delete(Long dni) {
        final var entidad = this.usuariosRepository.findById(dni)
            .orElseThrow(() -> new IllegalArgumentException("Usuario no encontrado con DNI: " + dni));
        
        this.usuariosRepository.delete(entidad);
    }

    private UsuariosResponse convertirEntidadAResponse(UsuariosEntity entidad) {
        return UsuariosResponse.builder()
                .dni(entidad.getDni())
                .nombre(entidad.getNombre())
                .apellido(entidad.getApellido())
                .email(entidad.getEmail())
                .build();
    }
}
