# BASE DE DATOS DE PRUEBA (ONLINE)

spring.datasource.url=${JDBC_DATABASE_URL}
spring.datasource.username=${JDBC_DATABASE_USERNAME}
spring.datasource.password=${JDBC_DATABASE_PASSWORD}

# --- MERCADO PAGO ---
# Token inyectado desde variable de entorno
mp.access.token=${MP_ACCESS_TOKEN}

# --- URLS DEL SISTEMA ---
# URLs inyectadas desde variables de entorno
app.backend.url=${APP_BACKEND_URL}
app.frontend.url=${APP_FRONTEND_URL}

# --- EMAIL (GMAIL SMTP con SSL) ---
spring.mail.host=smtp.gmail.com
# Cambiamos al puerto 465
spring.mail.port=465
spring.mail.username=${MAIL_USERNAME}
spring.mail.password=${MAIL_PASSWORD}

spring.mail.properties.mail.smtp.auth=true

# IMPORTANTE: Para puerto 465 usamos SSL directo, no STARTTLS
spring.mail.properties.mail.smtp.starttls.enable=false
spring.mail.properties.mail.smtp.ssl.enable=true

# Configuramos el Socket Factory para forzar SSL seguro
spring.mail.properties.mail.smtp.socketFactory.port=465
spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory
spring.mail.properties.mail.smtp.socketFactory.fallback=false

# Aumentamos el timeout a 10 segundos por si la red está lenta
spring.mail.properties.mail.smtp.connectiontimeout=10000
spring.mail.properties.mail.smtp.timeout=10000
spring.mail.properties.mail.transport.protocol=smtp

# --- SEGURIDAD JWT ---
# (Asumiendo que también externalizaste esto, si no, dejala hardcodeada solo por hoy)
jwt.secret.key=${JWT_SECRET_KEY}

# Ajustes del pool de conexiones
spring.datasource.hikari.maximum-pool-size=4
spring.datasource.hikari.minimum-idle=2

# Usamos MySQL
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

# IMPORTANTE: Configuración de inicialización
# "update" crea las tablas si no existen, pero NO borra los datos al reiniciar.
spring.jpa.hibernate.ddl-auto=update

# Solo la primera vez que lo corras, podés poner esto en 'always' para que cargue tu data.sql
# Después cambialo a 'never' para que no intente insertar los datos duplicados.
spring.sql.init.mode=never
